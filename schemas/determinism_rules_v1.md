# Determinism Rules v1 (NEW)

**Version:** v1  
**Purpose:** Make tool behavior reproducible and auditable across runs, especially for procedural generation and scene mutations.

---

## Determinism Classes

Each tool declares exactly one determinism class:

### 1) deterministic
- Same params + same contract + same initial state ⇒ same result/state
- Within defined canonicalization and float tolerance rules.

### 2) seeded
- Deterministic given an explicit seed.
- Seed must be provided as param OR inherited from contract (session seed).
- Seed must be propagated to all sub-operations (noise, random choices, sampling).

### 3) nondeterministic
- Depends on time, UI interaction, external services, unstable ordering, or context.
- Discouraged; allowed only when explicitly permitted by policy/contract.

---

## Canonicalization Requirements

To prevent accidental nondeterminism, tools MUST:

### Stable Ordering
- Sort entity lists by stable keys (e.g., type then name then id) before returning/hashing.
- Never rely on iteration order of Blender collections unless explicitly stabilized.

### Float Normalization
- If floats are returned or fingerprinted:
  - apply a consistent rounding policy, OR
  - include a declared tolerance and avoid claiming strict equality.
- Snapshot fingerprinting should use canonical float formatting (see `scene_state_v1.md`).

### Naming
- Avoid autogenerated names that depend on Blender counters (e.g., `Cube.001`).
- Prefer explicit names from inputs.
- If auto-generating:
  - generate names deterministically from stable inputs (e.g., prefix + short hash of params).

---

## Seed Handling

### Sources of Seed
A seed can come from:
- explicit tool param `seed`
- session contract `session_seed`
- macro/recipe wrapper seed (future feature)

Priority (recommended):
1) explicit tool param seed
2) session contract seed
3) refuse if seed required but missing

### Propagation
If a tool calls sub-tools or performs multi-step operations:
- use the same seed unless explicitly documented otherwise
- derive sub-seeds deterministically (e.g., `hash(seed, step_name)`)

### Refusal
If a caller requires deterministic/seeded behavior but the runtime cannot guarantee it:
- refuse with `nondeterministic_refused`

---

## Environmental Constraints

Determinism can be broken by:
- UI-only operations depending on selection/context
- external network calls / remote asset fetch
- time-based sampling
- non-stable filesystem reads (directory order)
- version differences (Blender, addons, drivers)

When any of these applies, tools must:
- refuse, or
- downgrade determinism under explicit contract opt-in (not in v1).

---

## Macro / Recipe Determinism

If a macro or recipe is defined as a sequence of tools:
- the macro inherits the strictest determinism requirements of its steps
- the macro must propagate seeds consistently
- the macro must enforce canonical ordering across step outputs if it aggregates data

---

## Deterministic Fingerprinting (Preview)

For any returned “state-like” data:
- compute fingerprints from canonical forms only
- include algorithm labels when hashing (e.g., `sha256`)
- ensure stable ordering of fields and collections (see `scene_state_v1.md`)
